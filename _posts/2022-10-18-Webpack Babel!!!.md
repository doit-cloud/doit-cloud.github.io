---
title: "Webpack과 Babel!"
toc: true
toc_sticky: true
categories: 

- dev

tags:

- JavaScript
- Webpack
- Babel

---


## 0.  개요

Webpack과 Babel.

프론트 개발자로 일하다보면 자주 듣는 말들이지만 딱히 실감은 나지 않습니다.

모듈화를 통한 성능향상이나 ES6+의 브라우저 대책, JSX와 TypeScript를 JavaScript로 변환?

그런데 나는 Webpack과 Babel 같은거 없이도 이미 잘쓰고 있지 않던가?

사실 여러분은 이미 Webpack, Babel을 잘 쓰고 있어요.

CRA(Create-React-App)나 다른 보일러 템플릿이 자동으로 구성해줬기에 모르고 있었을 뿐이죠.

내가 숨쉬듯 사용하던 세팅에 뭔지 모를게 섞여있다면 한번쯤은 알아봐야 되지 않을까요?

<br/>

## 1.  Webpack과 Babel은 왜 등장했을까요?

<br/>

### **(1) Babel**

2차 브라우저 전쟁이 진행되던 시기.
이번 이야기도 만악의 근원인 **Internet Explore**에서 출발합니다.

**IE**는 **ES5**가 제정되었지만, `JScript`만의 문법을 사용하는 등 독자노선을 걷고 있었습니다.

**IE**는 명실상부한 웹 브라우저계의 공룡이였기에, 그 행동은 점유율을 인질로 삼은 일종의 협박이였습니다.

하지만 언제나 그렇듯 개발자들은 정답을 찾았죠.

**Babel**의 원래 이름은  **6to5** 입니다. ‘6에서 5로 보낸다’ 라는 이름에서 짐작 가능하시겠지만,

**ES6(ECMAScript 6)**를 **ES5(ECMAScript 5)**로 바꿔주는 트랜스파일러를 의미합니다.

이러한 트랜스파일러들의 등장은 마이크로소프트의 패배에 영향을 끼쳤습니다.

<br/>

### **(2) Webpack**

Webpack은 모듈 번들러입니다.

모듈 번들러는 웹 애플리케이션을 구성하는 자원(HTML, CSS, Javscript, Images 등)을 조합하여 병합된 하나의 결과물을 만드는 도구를 의미하죠.

웹의 규모가 커져나가고 대규모 웹 프로젝트가 하나 둘 만들어지던 시절,

데이터의 양, 사용자 수, 웹 복잡성들이 모두 증가했기에 자원을 관리해야할 필요성에 의해 등장했습니다.

이런 흐름에 따라 웹 개발 시장에서 모듈 번들러에게 반영된 것은, 크게 3가지 이슈입니다.

<br/>

**1. 파일 단위의 자바스크립트 모듈 관리의 필요성**

자바스크립트의 변수 유효 범위는 기본적으로 전역 범위를 갖습니다. 

따라서 빌드시 중복선언으로 인한 문제가 무척 다분했고, js 파일을 모듈로서 관리해야 했습니다.

<br/>

**2. 웹 개발 작업 시 자동화 도구**

- HTML, CSS, JS 압축
- 이미지 압축
- CSS 전처리기 변환

과거에는 빌드를 위해 다음과 같은 작업들을 거쳐야했고, 이를 자동화 해주는 도구가 필요했습니다.

<br/>

**3. 웹 애플리케이션의 빠른 로딩 속도와 높은 성능 필요**

일반적으로 특정 웹사이트를 접근할 때, 5초이내로 사이트가 표시되지 않으면 사용자를 흥미를 잃는다고 합니다.

커져가는 데이터양에 맞춰서 웹 사이트의 로딩 속도를 높이기 위해 모듈 번들러가 필요했습니다.

<br/>

## 2.  왜 같이 쓸까요?

위에서 잠깐 알아본 바에 따르면, Webpack과 Babel은 그 배경과 목적이 다른 것 같습니다.

그렇다면 어째서 서로가 Google 연관 검색어를 차지할 정도로 같이 언급될까요?

그것은 서로가 완전히 다르지만 상호 보완적인 도구 집합이기 때문입니다.

주요 목적들은 다음과 같습니다.

<br/>

**1. 모듈 병용의 목적**

자바스크립트는 2015년 이전까지는 공식적으로 모듈을 지원하지 않았습니다.

**ECMAScript2015** 이전에는 모듈에 대한 표준이 따로 존재하지 않았다는 말이죠.

때문에 개발자 커뮤니티 에서는 다음과 같은 모듈 시스템들을  자체적으로 만들어 사용했습니다.

하지만 시간이 지나 ES6에서 공식 모듈 표준인 ES Module(ESM)가 등장하였고, 

기존의 모듈로 개발된 라이브러리나 코드 또한 계속해서 사용되어야 했기에 모듈 병용이 필요해졌습니다.

모듈 병용의 목적으로 사용되는 Webpack은 자체적인 트랜스파일링이 가능 하지만 

ES6+ 이상의  기능을 사용하는 있는 경우가 있을 수도 있기에, **Babel을 함께 구성하는 것이 ‘권장’되고 있습니다.**

<br/>

**2. 라이브러리간 지원**

Webpack은 다양한 Plugin, Loader, Freeset 들을 통하여 지원 기능들을 확장하고 있습니다.

서로를 올바르게 사용하기 위한 단계별 지침이 공식문서로 지원되고 있기 때문에같이 사용하기에 정말 편리합니다

<br/>

**3. 기능상의 이유**

앞서 말했듯, 두 라이브러리가 같이 쓰이는 이유는 상호 보완적인 도구 집합이기 때문입니다.

자바스크립트는 브라우저간 차이, 모듈화 지원  차이 같은 문제들을 갖고 있는 엉망인 언어지만.

Webpack과 Babel을 함께 사용하여 이러한 모든 문제들을 동시에 처리할 수 있습니다.

<br/>

## 2.1  최근의 경우

webpack-2 이후로, babel7 이후로 서로가 업데이트를 거듭하여,

이제는 그렇게까지 필수가결한 존재는 아니게되었다고 생각됩니다. 사례를 몇개 들어 볼까요?

<br/>

### (1) **Babel의 경우**

polyfill은 충전솜이라는 뜻을 가지고 있습니다. 브라우저에서 지원하지 않는 코드 조각이나 기능을 의미 합니다.

 

앞서 말했듯이 Babel은 ES6를 읽을 수 있는 문법으로 변경시켜주는 역할을 담당합니다.

하지만 이전에 없는 기능들이 새로나온 경우에는 문제가 생깁니다. Promise, Set, Map이 그 대표적인 예죠.

Babel 또한 @babel/polyfill 패키지를 통해 이를 지원하였지만

이제는 es6-promise-promise로 webpack 빌드에 직접 포함되도록 설계되었습니다.

라이브러리의 기능 자체가 확장되면서 Babel에 대한 의존성이 줄어든 것입니다.

<br/>

### (2) **Webpack의 경우**

Babel은 7버전 이후로 더 많은 라이브러리들과 호환되기 시작하였습니다.

Webpack의 대체재인 Rollup 또한 @*rollup*/plugin-*babel*을 통해 손쉽게 babel과의 연동이 가능합니다.

게다가 zero config를 특징으로 갖는 parcel에 이르러서는 별도의 설정 없이,

babel을 설치하기만 하더라도 프로젝트에 root 있는 .babelrc 파일을 자동으로 읽어와서 세팅을 마쳐주기도 합니다.

<br/>

### (3) 결론

이처럼 webpack과 babel을 과거에 비하면 서로에게 덜 필수적이게 되었습니다.

물론 여전히 서로가 좋은 사용처이고 대규모 프로젝트에서 같이 사용될 때도 굉장히 많습니다.

허나 무조건적으로 Webpack과 Babel을 사용하는것이 아닌  성능 및 필요에 따라,

타 라이브러리와 비교 및 취사 선택이 필요해졌다고 생각됩니다.

<br/>

## 3.  동작 원리 및 흐름

각 라이브러리들의 동작 원리 및 흐름은 다음과 같습니다.

<br/>

### **(1) Babel**

<br/>

**1단계:  파싱(Parsing)**

Babel은 먼저 소스코드를 가지고 추상적인 형태의 코드로 변환 하는 과정을 수행합니다.
그리고 이 추상적인 형태의 코드를 '추상 구문 트리'(AST: Abstract Systax Tree)라고 부릅니다.

babel-parser에 의해 작성됩니다.

<br/>

**2단계:  변환(Transformation)**

이전 단계에서 파싱된 '추상 구문 트리'를 받아와  babel-traverse에 의해 재작성 됩니다.

각 브라우저 환경에 맞게 적절한 형태로 변환 될 수 있도록 변형 과정을 거쳐,
새로운 추상트리로 바뀌게 됩니다.

babel Plugin중 preset/plugin에 의해 처리되는 곳 이기도 합니다.

<br/>

**3단계: 코드 생성(Generation)**

새로운 '추상 구문 트리'를 환경에 맞는 실제 소스 코드로 변환하는 과정이 이뤄집니다.

<br/>

### **(2)** Webpack

<br/>

**1단계: 엔트리(Entry)**

엔트리는 번들링을 시작하기 위한 최초 진입점입니다. 웹팩은 이로부터 의존적인 모듈을 전부 찾아냅니다.

이때 모듈 간의 의존 관계로 생기는 구조를 디펜던시 그래프(Dependency Graph)라고 합니다.

<br/>

**2단계: 로더(Loader)**

엔트리에서 찾아낸 모든 모듈들은, 아직 읽을 수 없습니다. 웹팩은 자바스크립트 밖에 읽지 못하기 때문이죠.

따라서 HTML, CSS, Images, 폰트 등을 읽을 수 있게 변환해줘야 하는데,  이 역할을 하는 게 바로 로더입니다.

<br/>

**3단계: 아웃풋(Output)**

이렇게 해석된 모듈들은 이제 병합 할 수있게 되었습니다.
모든 모듈을 하나로 묶어 하나의 결과물로 만들고, 그것이 위치하는 경로를 아웃풋 이라고 합니다.

<br/>

**4단계: 플러그인(Plugin)**

플러그인은 공식 문서에서는 로더가 할 수 없는 다른 작업을 수행한다고 설명하고 있습니다.

다시말해 최종적으로 생성된 결과물에 대해 추가적인 작업이 필요하다면 플러그인을 통해 처리하는 것이지요

<br/>

## 4.  Webpack, 대안 비교 분석

앞서 말했듯이, Babel의 파트너로 사용되기에 더 이상 Webpack은 필수적이지만은 않습니다.

다른 라이브러리와 비교했을 때 갖는 장단점을 의주로 분석해봅시다.

<br/>

### **(1) Babel**

![img4]({{site.url}}/assets/images/kjh/webpack_babel!!/img4.png)

**. 장점**

우선 오래된 만큼 생태계가 풍부하고 안전성이 뛰어난 번들러입니다. Parcel의 Zero Config가 가끔씩 문제를 일으킨는걸 생각하면 분명한 장점입니다.

또한 서드파티 라이브러리 관리나 CSS 전처리, 이미지 에셋 관리 등에 있어서 타 번들러보다 강점을 보입니다.

코드 스플리팅에 있어서는 조금 뒤쳐지지만, 안정성면에서는 Webpack이 낫습니다.

활성화된 단계에서의 빌드 시간 또한 Webpack이 가장 빠르다고 하더군요.

<br/>

**. 단점**

복잡한 문서와 추가 작업등이 단점으로 꼽힙니다. 이후에 등장할 모듈러들이 이점에서 차별점을 보인 경우가 많아서 더 비교가 됩니다.

<br/>

###**(2) Rollup**

![img5]({{site.url}}/assets/images/kjh/webpack_babel!!/img5.png)

Rollup은 대체로 Webpack과 유사합니다.

<br/>

**. 장점**

ES6 모듈 형식으로 빌드 결과물을 출력할 수 있으므로, 이를 라이브러리나 패키지 개발에 활용할 수 있다는 것 입니다. 자체적인 로더를 가진 다른 번들러들과는 달리 ESM을 기본으로 따르거든요.

이로인해 코드 스플리팅 측면에서 다른 번들러와 비교해 강점이 보입니다.

중복제거에 특화되어 있는데, 특히 진입점이 여러개 있을 때 이 부분이 두드러진다고 합니다.

<br/>

**. 단점**

**Webpack과의 유사성**이 단점입니다. 차이가 얼마 없다면, Webpack의 생태계를 포기할 이유가 별로 없거든요

<br/>

### **(3) Parcel**

![img6]({{site.url}}/assets/images/kjh/webpack_babel!!/img6.png)

**. 장점**

대표적인 특징은 앞서 언급했던 Zero Config입니다. 설정 필요없이, 설치만하면 별도의 파일없이 동작합니다.

이는 자바스크립트 엔트리 포인트를 지정해주는 것이 아니라, 애플리케이션 진입을 위한 HTML 파일 자체를 읽기 때문입니다.

<br/>

**. 단점**

Webpack과 Rollup에 비하면 생태계가 다소 부족하고, 안정성이 떨어집니다.

<br/>

### 결론

- 많은 서드파티를 필요로 하는 복잡한 애플리케이션은 Webpack
- 최소한의 서드파티로 라이브러리를 만들고 싶다면 Rollup
- 복잡한 설정을 피하고 간단한 애플리케이션을 만들고 싶다면 Parcel

<br/>

## 참조 게시글

babel과 Webpack

 [https://velog.io/@code-bebop/babel과-webpack](https://velog.io/@code-bebop/babel%EA%B3%BC-webpack)

JavaScript 번들러로 본 조선시대 붕당의 이해 

[https://yozm.wishket.com/magazine/detail/1261/](https://yozm.wishket.com/magazine/detail/1261/)

웹팩을 사용하지 말아야 하는 이유

[https://dimzou.feat.com/ko-KR/draft/559045](https://dimzou.feat.com/ko-KR/draft/559045)

바벨과 타입스크립트의 아름다운 결혼

[https://ui.toast.com/weekly-pick/ko_20181220](https://ui.toast.com/weekly-pick/ko_20181220)
