---
title: "Webpack Babel!!!"
toc: true
toc_sticky: true
categories: 

- dev

tags:

- JavaScript
- Webpack
- Babel

---

## 0.  개요

Webpack과 Babel,

프론트 개발자로 일하다보면 자주 듣는 말들이지만

딱히 실감은 나지 않습니다.

모듈화를 통한 성능향상?

ES6+의 브라우저 대책?

JSX와 TypeScript를 JavaScript로 변환?

흠 이렇게 적어놔도 별로 감흥은 없군요.

하지만 여러분이 만약 React를 시작한지 얼마안된 주니어 개발자라면 조금은 신경쓰이는 단어가 있을지도 모릅니다.

JSX를 변환?

하지만 나는 Webpack과 Babel 같은거 없이도 이미 잘쓰고 있는데??

짝짝짝 축하합니다. 

당신은 이미 Webpack, Babel을 쓰고 있어요.

CRA(Create-React-App)이나 다른 보일러 템플릿이 자동으로 구성해줬기에 모르고 있었을 뿐이죠.

모를때는 상관없었지만 내가 숨쉬듯 사용하던 세팅에

음이온인지 미세먼지인지 모를게 섞여있다면 한번은 알아봐야 되지 않을까요?

들어가기전에 해당 라이브러리들의 핵심 기능들에 대해 간단히 정리해 보았습니다.

Webpack

 - 모듈 번들링
 - build 작업 자동화
 - 웹 페이지 성능 최적화

Babel

- ES6+을 ES5으로 transfing
 - 정적 타입언어 transfing
 - 코드 압축

## 1.  Webpack과 Babel은 왜 등장했을까요?

### **(1) Babel**

**Once upon a time…**

브라우저 전쟁이 있었습니다.

많은 사람들이 알다시피, 최초의 브라우저 경쟁의 승자는 마이크로소프트였죠.

별로 중요하진 않지만, 넷스케이프가 패배자였고요

그리고 조금 더 시간이 지나고 세상의 웹 브라우저는 두 종류로 나누어 졌습니다.

바로 **ES6**(**ECMAScript 2015)를 지원하는가 하지 않는가죠!**

표준화 버전의 차이가 웹 브라우저를 선택하는 기준이 된다?

조금 과장 섞였다고 느끼실 수도 있겠지만,

당시의 개발자들에겐 무척이나 중요한 일이였습니다.

어쨌거나 효율 손실은 참을 수 없는 일이니까요!

![img1]({{site.url}}/assets/images/kjh/webpack_babel!!/img1.png)

▹ *거부하기에는 너무 강력한 기능이였습니다.*

강력한 기능으로 선보여진  **ES6**.

그렇다면 당연히 웹 브라우저들은 앞 다퉈 **ES6**를 지원하고,

개발자들은 새롭고 놀라운 기능을 누리는 행복한 결말이겠죠?

웹 브라우저 역사속에서 이상한 일이 벌어졌을때, 

브라우저 하나를 찍으면 대충 맞습니다.

역시나 이번 이야기도 만악의 근원인 **Internet Explore**에서 출발합니다.

![img2]({{site.url}}/assets/images/kjh/webpack_babel!!/img2.png)

▹ *오늘도 IE는 세상을 따돌린다.*

당시는 2차 브라우저 전쟁이 진행되던 시기!

**ES5**가 제정되었지만,  **IE**의 **JScript**는 addEventListner와 attachEven 같은 

**JScript**만의 문법을 사용하는 등 독자노선을 걷고 있었습니다.

또한 **ES6**가 등장한 시점에서도 마찬가지였습니다 

본인들만의 기준을 세우겠다는 움직임이였죠

지금이야 역사속으로 사라져가는 중인 **IE**지만,

과거에는 명실상부한 웹 브라우저계의 공룡이였습니다.

그러므로 **IE**의 행동은 점유율을 인질로 삼은 일종의  공공연한 협박이였죠.

그렇다면 결국 개발자들이 굴복하고 마는 결말일까요?

언제나 그렇듯 개발자들은 정답을 찾아냅니다.

 **Babel**의 등장이죠!

사실 바벨이 등장했다기 보다는 트랜스 파일러의 등장인셈이지만요

---

**Babel**의 원래 이름은  **‘6to5**’ 입니다.

**“6에서 5로 보낸다"**에서 짐작 가능하시겠지만,

**ES6(ECMAScropt 6)**를 **ES5(ECMAScript 5**)로 바꿔주는 걸 의미했습니다.

이는 곧 ES6를 사용하면서도 IE의 점유율을 포기하지 않다도 된다는 뜻이기에

개발자들은 ES6를 포기하지 않아도 되는 행복한 결말을 맞이하게됩니다.

### **(2) Webpack**

그렇다면 **Webpack**은 어떨까요?

**Webpack**은 **모듈 번들러**입니다.

**모듈 번들러**는 웹 애플리케이션을 구성하는 자원(HTML, CSS, Javscript, Images 등)을 

조합하여 병합된 하나의 결과물을 만드는 도구를 의미하죠.

**Webpack**은  **Babel** 처럼,

딱히  드라마틱 한 등장 배경을 가진 것은 아니였습니다.

여느 라이브러리들 처럼 수요에 의해 탄생하였고,

이는 모듈 번들러로서의 핵심 기능이 곧 등장배경이 되는 셈이지요.

간단하게나마 모듈 번들러가 요구된 당시의 배경을 말해보자면, 

웹이 등장하고 점차 규모가 커져나가고 대규모 웹 프로젝트가 하나 둘 만들어지던 시절.

웹 서비스의 규모가 증가하면서 데이터의 양, 사용자 수, 웹 복잡성들이 모두 증가했기에

웹 어플리케이션을 구성하는 자원을 관리해야할 필요성이 생긴것입니다.

이런 흐름에 따라 웹 개발 시장에서 모듈 번들러에게 반영된 것은,

크게 3가지 이슈라고 생각됩니다.

1. **파일 단위의 자바스크립트 모듈 관리의 필요성**

자바스크립트의 변수 유효 범위는 기본적으로 전역 범위를 갖습니다.

최대한 넓은 변수 범위를 갖기에 어디에서도 접근 가능합니다.

그렇기에  빌드시 중복선언으로 인한 문제가 무척 다분했습니다. 

이런 이슈로 인해 js 파일을 모듈로써 관리해야할 필요성이 생겼습니다.

프로젝트들의 규모가 커진 시점에선 이러한 필요성은 더더욱 커졌고요.

1. **웹 개발 작업 시 자동화 도구**

본인이 모듈 번들러가 생소함에도 불구하고

명령어 한번으로 손쉽게  build 작업을 완료하고 있었다면

앞선 개발자들에게 감사하는 마음을 갖도록 합시다.

- HTML, CSS, JS 압축
- 이미지 압축
- CSS 전처리기 변환

과거에는 위와 같은 작업들을 거쳐야했고

이를 자동화 해주는 도구가 필요했습니다.

1. **웹 애플리케이션의 빠른 로딩 속도와 높은 성능 필요**

일반적으로 특정 웹사이트를 접근할 때,

5초이내로 사이트가 표시되지 않으면 사용자를 흥미를 잃는다고 합니다.

따라서 웹 사이트의 로딩 속도를 높이기 위해 많은 개발자들은 다분히 노력해왔죠

커져가는 데이터양에 맞춰서 생긴 당연한 수요라고 생각됩니다.

## 2.  왜 같이 쓸까요?

위에서 잠깐 알아본 바에 따르면,

Webpack과 Babel은 그 배경과 목적이 다른 것 같습니다.

그렇다면 어째서 서로가 Google 연관 검색어를 차지할 정도로 같이 언급될까요?

그것은 서로가 완전히 다르지만 상호 보완적인 도구 집합이기 때문입니다.

같이 사용했을때, 더 극적인 성능을 이끌어 낼 수 있다는 것이죠.

![img3]({{site.url}}/assets/images/kjh/webpack_babel!!/img3.png)

▹  *Webpack과 Babel은 아름다운 한 쌍입니다.*

그렇다면 구체적으로 어떤점에서 같이 쓰는 것이 좋은까요?

1. **모듈 병용의 목적**

무척이나 경악스럽게도, 

자바스크립트는 2015년 이전까지는 공식적으로 모듈을 지원하지 않았습니다.

**ECMAScript2015** 이전에는 모듈에 대한 표준이 따로 존재하지 않았다는 말이죠.

때문에 개발자 커뮤니티 에서는

- node.js의 CommonJS
- RequireJS를 사용하는 Asynchronous Module Definition(AMD),
- UMD

위와 같은 모듈 시스템들을  자체적으로 만들어 사용했습니다.

하지만 앞서 말했듯, 

ES6에서는 대격변이라 할만큼 많은 것들이 달라졌습니다.

자바스크립트의 공식 모듈 표준인 ES Module(ESM) 역시 그 중 하나입니다.

ESM은  빠르게 기존의 모듈들을 대체해 나갔지만,

전부는 아니였습니다.

왜냐하면 기존의 모듈로 개발된 라이브러리나 코드 또한 계속해서 사용되어야 했으니까요.

현재에 와서도  CommonJS는 node.js와 같이 여전한 쓰임처를 보이고 있습니다.

결국 자바스크립트에 표준 모듈 시스템이 너무 늦게 출현한 것 때문에,

우리는 서로 다른 모듈 방식을 같이 쓰기 위한 추가적인 처리를 필요로 하게 된것이죠.

이에 대한 방법론으로 사용되는 것이 바로 모듈 번들러들입니다.

모션 번들러는 Bundleing을 통해 연관성을 가진 여러 모듈을 하나의 번들파일로 묶어줍니다.

설사 서로 다른 모듈화 방식을 채용하고 있더라도 말이죠

ESM에서 CommonJS 모듈을 가져오고, 

CommonJS 모듈에서 ESM을 가져올 수 있도록 해주는 식으로 말입니다.

그렇다면 어떻게 Webpack에서는 두 모듈을 함께 사용할 수 있도록 처리할까요?

결론부터 말하자면 일종의 Transpiling의 과정을 거치는 것 입니다.

ESM을 CommonJS 모듈과 함께 사용할 수 있게 코드를 변환 하는것이죠.

Transpiling?  여기서 감이 오셨을지도 모르지만,

모듈 표준의 변환이 필요하기에 Babel을 함께 사용하는 것 입니다.

사실 요즘의 Webpack은 자체적으로도 모듈의 완전한 Transpiling이 가능합니다.

ES6까지는 말이죠.

 

하지만 ES6+ 이상의  기능을 사용하는 있는 경우가 있을 수도 있기 때문에,

**공식적으로도** **Babel을 함께 구성하는 것이 ‘권장’되고 있습니다.**

1. **라이브러리간 지원**
    
    
    서로간에 사용하기 간편하다는 것 또한 한 이유가 될 수 있을것 입니다.
    
    Webpack은 다양한 Plugin, Loader, Freeset 들을 통하여 기능을 확장하고 있습니다.
    
    babel-loaders 같은 패키지등을 통해 환경을 구축하였죠.
    
    같이 사용하는걸 상정하고 개발을 진행했다고 해도 과언이 아니니까요.
    
    또한 서로를 올바르게 사용하기 위한 단계별 지침이 공식문서로 지원되고 있기 때문에
    
    같이 사용하기에 정말 편리합니다!
    

1. **기능상의 이유**
    
    
    앞서 말했듯, 두 라이브러리가 같이 쓰이는 이유는 상호 보완적인 도구 집합이기 때문입니다.
    
    정확히 말하면, Webpack이 필요로 하는 기능을 Babel이 보충해줄 수 있는것이지요.
    
    자바스크립트는 브라우저간 차이, 모듈화 지원  차이 같은 문제들을 갖고 있는 엉망인 언어지만.
    
    Webpack + Babel을 함께 사용하여 이러한 모든 문제들을 동시에 처리할 수 있습니다.
    
    그렇기 때문에 CRA(Create-React-App)을 포함한 많은 보일러 템플릿에서는
    
    두 라이브러리의 설정을 기본적으로 갖춰줍니다.
    

## 번외 2.1  사실 별로 친하지 않다?

요즈음에는 사정이 좀 달라졌습니다.

앞에 쓰인 같이 써야하는 이유들도 지금에와선 그렇게 중요하진 않습니다.

모듈 번들러와 트랜스파일러의 관계이지, 

반드시 webpack과 babel일 필요는 없거든요

물론 과거에는 이 두 라이브러리가 하나의 취급을 받을정도로 서로에게 종속적이였던 것이 맞습니다.

하지만 webpack-2 이후로, babel7 이후로 서로가 업데이트를 거듭하여,

이제는 그렇게까지 필수가결한 존재는 아니게되었다고 생각됩니다.

사례를 몇개 들어 볼까요?

---

먼저 ****polyfill****가 있습니다.

polyfill은 충전솜이라는 뜻을 가지고 있는데, 

브라우저에서 지원하지 않는 코드 조각이나 추가 기능을 의미 합니다.

 

앞서 말했듯이 Babel은 ES6를 지원하지 않는 구형 브라우저가 읽을 수 있는 문법으로 변경시켜주는 역할을 담당했는데요

하지만 그저 사용하는 방식이 변경된게 아닌, 이전에 없는 기능들이 새로나온 경우에는 변경시킬 수 없기에 문제가 생기곤 했습니다.

 Promise, Set, Map이 그 대표적인 예죠.

인형에 솜을 채우듯이 새롭게 코드 정보를 추가할 필요가 생겼기 때문에, 

Babel 또한 @babel/polyfill 패키지를 통해 이를 지원하였습니다.

그렇기에 webpack에서 babel을 사용할 때는

 @babel loader와 더불어 @babel/polyfill는 필수적인 패키지로 여겨지곤 했습니다.

지금은 아니지만요. 

이제는 es6-promise-promise로 webpack 빌드에 직접 포함되도록 설계되었습니다.

설령 webpack을 babel과 함께 사용한다고 하더라도,

 polyfill을 사용할 필요는 없게되었습니다.

또한  앞서 설명했듯 webpack-2에 이르러서는 어느정도 자체인 Transpiling 기능을 구현하기도 하였습니다.

라이브러리의 기능 자체가 확장되면서 Babel에 대한 의존성, 

더 나아가  Transper에 대한 의존성이 줄어든 것입니다.

---

반대 경우도 마찬가지입니다.

 

Babel은 7버전 이후로 더 많은 라이브러리들과 호환되기 시작하였습니다.

Webpack의 대체재로 평가 받는 Rollup 또한 @*rollup*/plugin-*babel* 플러그인을 통해 손쉽게

babel과의 연동이 가능합니다.

게다가 zero config를 특징으로 갖는 parcel에 이르러서는 별도의 설정 없이,

babel을 설치하기만 하더라도 프로젝트에 root 있는 .babelrc 파일을 자동으로 읽어와서 세팅을 마쳐주기도 합니다.

이처럼 webpack과 babel을 과거에 비하면 서로에게 덜 필수적이게 되었습니다.

단독으로 사용되는 경우도 늘어났고 비슷한 기능을 가진 라이브러리들이 늘어났으니까요

말하고 싶은바가 뭐냐면, 

여전히 서로가 좋은 사용처이고 대규모 프로젝트에서 같이 사용될 때도 굉장히 많습니다.

허나 무조건적으로 Webpack과 Babel을 사용하는것이 아닌  성능 및 필요에 따라,

타 라이브러리와 비교 및 취사 선택이 필요해졌다고 생각됩니다.

# 3.  동작 원리 및 흐름

다음으로는 각 라이브러리들의 동작 원리 및 흐름에 대해 알아보겠습니다

### **(1) Babel**

**1단계: 파싱(Parsing)**

Babel은 먼저 소스코드를 가지고 추상적인 형태의 코드로 변환 하는 과정을 수행합니다.
그리고 이 추상적인 형태의 코드를 '추상 구문 트리'(AST: Abstract Systax Tree)라고 부릅니다.

babel-parser에 의해 작성됩니다.

**2단계: 변환(Transformation)**

이전 단계에서 파싱된 '추상 구문 트리'를 받아와  babel-traverse에 의해 재작성 됩니다.

각 브라우저 환경에 맞게 적절한 형태로 변환 될 수 있도록 변형 과정을 거쳐,
새로운 추상트리로 바뀌게 됩니다.

babel Plugin중 preset/plugin에 의해 처리되는 곳 이기도 합니다.

**3단계: 코드 생성(Generation)**

새로운 '추상 구문 트리'를 환경에 맞는 실제 소스 코드로 변환하는 과정이 이뤄집니다.

### **(2)** Webpack

**1단계: 엔트리(Entry)**

엔트리는 번들링을 시작하기 위한 최초 진입점입니다. 
웹팩은 이 진입점으로부터 의존적인 모듈을 전부 찾아냅니다.

이때 모듈 간의 의존 관계로 생기는 구조를 디펜던시 그래프(Dependency Graph)라고 합니다.

**2단계: 로더(Loader)**

엔트리에서 찾아낸 모든 모듈들은, 아직 읽을 수 없습니다.
웹팩은 자바스크립트 밖에 읽지 못하기 때문이죠.

따라서 HTML, CSS, Images, 폰트 등을 웹팩이 읽을 수 있게 변환해줘야 하는데, 
이 역할을 하는 게 바로 로더입니다.

**3단계: 아웃풋(Output)**

이렇게 해석된 모듈들은 이제 병합 할 수있게 되었습니다.
모든 모듈을 하나로 묶어 하나의 결과물로 만들고, 그것이 위치하는 경로를 아웃풋 이라고 합니다.

**4단계: 플러그인(Plugin)**

플러그인은 한마디로 정의하기가 어렵지만, 
공식 문서에서는 로더가 할 수 없는 다른 작업을 수행한다고 설명하고 있습니다.

다시말해 최종적으로 생성된 결과물에 대해 추가적인 작업이 필요하다면
플러그인을 통해 처리하는 것이지요

## 4.  Webpack, 대안 비교 분석!

앞서 말했듯이, Babel의 파트너로 사용되기에 더 이상 Webpack은 필수적이지만은 않습니다.

게다가 단순 Transpiling 기능만을 제공하는 Babel과는 달리,

기능이 웹의 속도와 성능에 직격되는 모듈 번들링을 제공하는 Webpack에겐,

 많은 라이벌들이 나타났습니다.

다른 라이브러리와 비교했을 때 갖는 강점을 의주로 분석해봅시다.

### **(1) Babel**

![img4]({{site.url}}/assets/images/kjh/webpack_babel!!/img4.png)

비교에 앞서 Webpack이 가진 고유한 강점에 대해서도 알아보도록 하죠.

우선 오래된 만큼 생태계가 풍부하고 안전성이 뛰어난 번들러입니다.

Parcel의 Zero Config가 가끔씩 문제를 일으킨는걸 생각하면 굉장히 선녀죠.

또한 서드파티 라이브러리 관리나 CSS 전처리, 이미지 에셋 관리 등에 있어서 다른 번들러보다 강점을 보입니다.

코드 스플리팅에 있어서는 조금 뒤쳐지지만, 안정성면에서는 Webpack이 낫습니다.

코드 스플리팅이 활성화된 단계에서의 빌드 시간 또한 Webpack이 가장 빠르다고 하더군요.

하지만 복잡한 문서와 추가 작업등이 단점으로 꼽힙니다.

이후에 등장할 모듈러들이 이점에서 차별점을 보인 경우가 많아서 더 비교가 됩니다.

### **(2) Rollup**

![img5]({{site.url}}/assets/images/kjh/webpack_babel!!/img5.png)

Rollup은 대체로 Webpack과 유사하지만

가장 큰 차이점을 꼽으라면 ES6 모듈 형식으로 빌드 결과물을 출력할 수 있으므로,

 이를 라이브러리나 패키지 개발에 활용할 수 있다는 것 입니다.

자체적인 로더를 가진 다른 번들러들과는 달리 ESM을 기본으로 따르거든요.

이로인해 코드 스플리팅 측면에서 다른 번들러와 비교해 강점이 보입니다.

중복제거에 특화되어 있는데, 특히 진입점이 여러개 있을 때 이 부분이 두드러진다고 합니다.

### **(3) Parcel**

![img6]({{site.url}}/assets/images/kjh/webpack_babel!!/img6.png)

앞서 줄기차게 비교했던 Parcel입니다.

특징이라면 당연히 Zero Config!

설정이 필요없어요.

설치만하면 별도의 파일없이 동작합니다.

이는 자바스크립트 엔트리 포인트를 지정해주는 것이 아니라, 애플리케이션 진입을 위한 HTML 파일 자체를 읽기 때문입니다.

결론적으로

- 많은 서드파티를 필요로 하는 복잡한 애플리케이션은 Webpack
- 최소한의 서드파티로 라이브러리를 만들고 싶다면 Rollup
- 복잡한 설정을 피하고 간단한 애플리케이션을 만들고 싶다면 Parcel





참조 게시글

babel과 Webpack

 [https://velog.io/@code-bebop/babel과-webpack](https://velog.io/@code-bebop/babel%EA%B3%BC-webpack)

JavaScript 번들러로 본 조선시대 붕당의 이해 

[https://yozm.wishket.com/magazine/detail/1261/](https://yozm.wishket.com/magazine/detail/1261/)

웹팩을 사용하지 말아야 하는 이유

[https://dimzou.feat.com/ko-KR/draft/559045](https://dimzou.feat.com/ko-KR/draft/559045)

바벨과 타입스크립트의 아름다운 결혼

[https://ui.toast.com/weekly-pick/ko_20181220](https://ui.toast.com/weekly-pick/ko_20181220)
